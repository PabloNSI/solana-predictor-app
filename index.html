<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Predictor - Gr√°ficos por A√±o Completos</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        /* Estilos id√©nticos a tu versi√≥n anterior - sin emoticonos */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }
        
        @media (max-width: 768px) {
            .container { grid-template-columns: 1fr; }
        }
        
        header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 24px 0;
            border-bottom: 1px solid #334155;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00ffa3, #03e1ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 12px;
        }
        
        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid #475569;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 500px;
        }
        
        .chat-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid #475569;
        }
        
        .chat-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #00ffa3, #03e1ff);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            color: #0f172a;
        }
        
        .chat-history {
            flex: 1;
            overflow-y: auto;
            padding-right: 8px;
            margin-bottom: 20px;
        }
        
        .message {
            margin-bottom: 16px;
            animation: fadeIn 0.3s ease;
        }
        
        .user-message {
            text-align: right;
        }
        
        .bot-message {
            text-align: left;
        }
        
        .message-bubble {
            display: inline-block;
            padding: 12px 18px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .user-message .message-bubble {
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            color: white;
            border-bottom-right-radius: 4px;
        }
        
        .bot-message .message-bubble {
            background: rgba(71, 85, 105, 0.7);
            border-bottom-left-radius: 4px;
            color: #e2e8f0;
        }
        
        .message-time {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 4px;
            margin-left: 10px;
        }
        
        .chat-input-container {
            display: flex;
            gap: 12px;
            margin-top: auto;
        }
        
        #userInput {
            flex: 1;
            padding: 14px 18px;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid #475569;
            border-radius: 12px;
            color: white;
            font-size: 1rem;
            outline: none;
            transition: border 0.3s;
        }
        
        #userInput:focus {
            border-color: #00ffa3;
        }
        
        #sendButton {
            padding: 14px 24px;
            background: linear-gradient(90deg, #00ffa3, #03e1ff);
            color: #0f172a;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        #sendButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 163, 0.3);
        }
        
        .chart-container {
            height: 300px;
            margin-bottom: 24px;
        }
        
        .analysis-card {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
            border-left: 4px solid #00ffa3;
        }
        
        .indicator-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 20px;
        }
        
        .indicator {
            text-align: center;
            padding: 16px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
        }
        
        .indicator-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 8px 0;
        }
        
        .positive { color: #00ffa3; }
        .neutral { color: #03e1ff; }
        .warning { color: #fbbf24; }
        
        .query-examples {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        .query-example {
            padding: 8px 16px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .query-example:hover {
            background: rgba(71, 85, 105, 0.8);
        }
        
        footer {
            grid-column: 1 / -1;
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #334155;
            color: #94a3b8;
            font-size: 0.9rem;
        }
        
        .disclaimer {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin: 20px 0;
            color: #fca5a5;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #94a3b8;
        }
        
        .loading::after {
            content: "";
            width: 20px;
            height: 20px;
            border: 2px solid #00ffa3;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .pulse {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Solana Predictor</h1>
            <p class="subtitle">Gr√°ficos completos por a√±o y per√≠odo - Datos reales y simulados</p>
            <div class="disclaimer">
                SIMULACI√ìN ACAD√âMICA: Gr√°ficos anuales incluyen datos simulados para completar el a√±o 2025.
            </div>
        </header>
        
        <div class="card">
            <div class="chat-container">
                <div class="chat-header">
                    <div class="chat-icon">AI</div>
                    <div>
                        <h2>Asistente de An√°lisis</h2>
                        <p style="color: #94a3b8; font-size: 0.9rem;">Pide gr√°ficos por a√±o (2025) o per√≠odo espec√≠fico</p>
                    </div>
                </div>
                
                <div class="chat-history" id="chatHistory">
                    <div class="message bot-message">
                        <div class="message-bubble">
                            <div class="loading">Cargando datos hist√≥ricos de Solana...</div>
                        </div>
                        <div class="message-time">Ahora</div>
                    </div>
                </div>
                
                <div class="chat-input-container">
                    <input type="text" id="userInput" placeholder="Esperando datos..." autocomplete="off" disabled>
                    <button id="sendButton" disabled>Enviar</button>
                </div>
                
                <div class="query-examples" id="queryExamples" style="display: none;">
                    <div class="query-example" onclick="insertExample('gr√°fico de 2025')">Gr√°fico 2025</div>
                    <div class="query-example" onclick="insertExample('gr√°fico anual')">Gr√°fico anual</div>
                    <div class="query-example" onclick="insertExample('gr√°fico de este a√±o')">Este a√±o completo</div>
                    <div class="query-example" onclick="insertExample('gr√°fico de los √∫ltimos 30 d√≠as')">√öltimos 30 d√≠as</div>
                    <div class="query-example" onclick="insertExample('gr√°fico de los √∫ltimos 7 d√≠as')">√öltimos 7 d√≠as</div>
                    <div class="query-example" onclick="insertExample('predice el precio para ma√±ana')">Predice ma√±ana</div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="chat-header">
                <div class="chat-icon">VC</div>
                <div>
                    <h2>Visualizaciones Din√°micas</h2>
                    <p style="color: #94a3b8; font-size: 0.9rem;">Los gr√°ficos anuales muestran datos simulados para completar 2025</p>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
            
            <div id="analysisResults">
                <div class="analysis-card">
                    <h3>Informaci√≥n Actual de SOL</h3>
                    <p>Cargando datos hist√≥ricos desde el archivo CSV...</p>
                </div>
                
                <div class="indicator-grid" id="indicators">
                    <!-- Los indicadores se generar√°n aqu√≠ -->
                </div>
            </div>
        </div>
        
        <footer>
            <p>Proyecto Final Unit 25: Applied Machine Learning ‚Ä¢ Pearson HND ‚Ä¢ SIMULACI√ìN ACAD√âMICA</p>
            <p style="margin-top: 8px; font-size: 0.8rem;">Datos reales hasta 2025 ‚Ä¢ Gr√°ficos anuales con simulaci√≥n</p>
        </footer>
    </div>

    <script>
        // ============================================
        // CONFIGURACI√ìN PRINCIPAL Y VARIABLES GLOBALES
        // ============================================
        const ctx = document.getElementById('priceChart').getContext('2d');
        let priceChart;
        let historicalData = [];
        let processedData = [];
        let lastRealDate = null;
        let lastRealPrice = 0;
        let currentSimulatedDate = null;
        let currentSimulatedPrice = 0;
        let lastQueryType = '';
        
        // Fecha de simulaci√≥n: 1 de enero de 2025 (como si estuvi√©ramos en 2025)
        const SIMULATION_DATE = new Date('2025-01-01');
        
        // ============================================
        // FUNCIONES DE CARGA Y PROCESAMIENTO DE DATOS
        // ============================================
        
        async function loadCSVData() {
            try {
                const response = await fetch('sol_1d_data_2020_to_2025.csv');
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                const csvText = await response.text();
                
                // Usamos PapaParse para procesar el CSV
                return new Promise((resolve, reject) => {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            if (results.errors && results.errors.length > 0) {
                                console.warn('Errores en el parseo:', results.errors);
                            }
                            historicalData = results.data;
                            processHistoricalData();
                            resolve();
                        },
                        error: function(error) {
                            reject(error);
                        }
                    });
                });
            } catch (error) {
                console.error('Error cargando CSV:', error);
                // Fallback a datos de ejemplo si el CSV no se puede cargar
                createFallbackData();
                processHistoricalData();
            }
        }
        
        function processHistoricalData() {
            // Filtrar y procesar los datos
            processedData = historicalData
                .filter(row => row['Open time'] && row['Close'] && !isNaN(row['Close']))
                .map(row => {
                    const date = new Date(row['Open time']);
                    return {
                        date: date,
                        open: row['Open'] || 0,
                        high: row['High'] || 0,
                        low: row['Low'] || 0,
                        close: row['Close'] || 0,
                        volume: row['Volume'] || 0,
                        trades: row['Number of trades'] || 0,
                        isReal: true
                    };
                })
                .sort((a, b) => a.date - b.date); // Ordenar por fecha
                
            // Encontrar el √∫ltimo dato real (antes de la fecha de simulaci√≥n)
            const realData = processedData.filter(d => d.date <= SIMULATION_DATE);
            
            if (realData.length > 0) {
                const lastReal = realData[realData.length - 1];
                lastRealDate = lastReal.date;
                lastRealPrice = lastReal.close;
                currentSimulatedDate = new Date(SIMULATION_DATE);
                currentSimulatedPrice = lastRealPrice;
                
                console.log(`Datos cargados: ${processedData.length} registros reales`);
                console.log(`√öltimo dato real: ${lastRealDate.toLocaleDateString()} - $${lastRealPrice}`);
            }
        }
        
        // ============================================
        // NUEVAS FUNCIONES PARA GR√ÅFICOS POR A√ëO
        // ============================================
        
        function generateYearData(year) {
            // Para a√±os anteriores a 2025: usar datos reales
            // Para 2025: combinar datos reales (hasta SIMULATION_DATE) con simulados
            
            const startDate = new Date(year, 0, 1);
            const endDate = new Date(year, 11, 31);
            
            // Obtener datos reales para este a√±o
            const realData = processedData.filter(d => 
                d.date.getFullYear() === year && d.isReal
            );
            
            // Si es 2025 y no hay suficientes datos, generar datos simulados
            if (year === 2025 && realData.length < 365) {
                return generateSimulatedYearData(realData, startDate, endDate);
            }
            
            // Para a√±os anteriores con datos reales
            return realData;
        }
        
        function generateSimulatedYearData(realData, startDate, endDate) {
            const simulatedData = [];
            
            // Si hay datos reales, usarlos como base
            let currentPrice = realData.length > 0 ? realData[realData.length - 1].close : lastRealPrice;
            const lastRealDataDate = realData.length > 0 ? 
                realData[realData.length - 1].date : 
                new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() - 1);
            
            // Generar datos para cada d√≠a del a√±o
            const currentDate = new Date(startDate);
            
            while (currentDate <= endDate) {
                // Si ya tenemos datos reales para esta fecha, usarlos
                const existingRealData = realData.find(d => 
                    d.date.getTime() === currentDate.getTime()
                );
                
                if (existingRealData) {
                    simulatedData.push(existingRealData);
                    currentPrice = existingRealData.close;
                } else {
                    // Generar dato simulado
                    // Para 2025, empezar desde el √∫ltimo dato real y generar una tendencia realista
                    const daysFromStart = Math.floor((currentDate - startDate) / (1000 * 60 * 60 * 24));
                    const volatility = 0.02; // 2% de volatilidad diaria
                    
                    // Tendencia base: crecimiento moderado para 2025
                    const baseTrend = 0.0003; // 0.03% de crecimiento diario
                    
                    // Variaci√≥n estacional (m√°s volatilidad en ciertos meses)
                    const month = currentDate.getMonth();
                    let seasonalFactor = 1.0;
                    if (month >= 10 || month <= 1) { // Nov-Feb: m√°s volatilidad
                        seasonalFactor = 1.2;
                    } else if (month >= 4 && month <= 7) { // May-Aug: menos volatilidad
                        seasonalFactor = 0.8;
                    }
                    
                    // Generar precio
                    const randomFactor = (Math.random() - 0.5) * 2 * volatility * seasonalFactor;
                    const trendFactor = baseTrend * daysFromStart;
                    
                    // Evitar ca√≠das bruscas al principio
                    const safeRandom = daysFromStart < 30 ? randomFactor * 0.5 : randomFactor;
                    
                    currentPrice = currentPrice * (1 + safeRandom + (trendFactor / 365));
                    
                    // Mantener precio positivo
                    currentPrice = Math.max(0.1, currentPrice);
                    
                    simulatedData.push({
                        date: new Date(currentDate),
                        close: currentPrice,
                        isReal: false,
                        isSimulated: true
                    });
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            return simulatedData;
        }
        
        // ============================================
        // FUNCIONES DE GENERACI√ìN DE PREDICCIONES
        // ============================================
        
        function generatePrediction(daysAhead = 1) {
            // Basar las predicciones en la volatilidad hist√≥rica de los √∫ltimos 30 d√≠as
            const recentData = getDataForPeriod(
                new Date(currentSimulatedDate.getTime() - 30 * 24 * 60 * 60 * 1000),
                currentSimulatedDate
            );
            
            if (recentData.length < 2) return currentSimulatedPrice;
            
            // Calcular volatilidad hist√≥rica
            const returns = [];
            for (let i = 1; i < recentData.length; i++) {
                const ret = (recentData[i].close - recentData[i-1].close) / recentData[i-1].close;
                returns.push(ret);
            }
            
            const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
            const variance = returns.reduce((a, b) => a + Math.pow(b - avgReturn, 2), 0) / returns.length;
            const volatility = Math.sqrt(variance);
            
            // Generar predicci√≥n
            const drift = avgReturn * daysAhead;
            const randomComponent = volatility * Math.sqrt(daysAhead) * (Math.random() - 0.5) * 2;
            
            const predictedPrice = currentSimulatedPrice * (1 + drift + randomComponent);
            return Math.max(0.1, predictedPrice);
        }
        
        // ============================================
        // FUNCIONES DE ACTUALIZACI√ìN DE GR√ÅFICOS
        // ============================================
        
        function initializeChart() {
            // Mostrar √∫ltimos 30 d√≠as por defecto
            const endDate = new Date(currentSimulatedDate);
            const startDate = new Date(currentSimulatedDate);
            startDate.setDate(startDate.getDate() - 30);
            
            const periodData = getDataForPeriod(startDate, endDate, false);
            
            // Limitar a 30 puntos para mejor visualizaci√≥n
            const sampledData = sampleData(periodData, 30);
            
            const labels = sampledData.map(d => 
                d.date.toLocaleDateString('es-ES', { month: 'short', day: 'numeric' })
            );
            
            const prices = sampledData.map(d => d.close);
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Precio de SOL (USD) - √öltimos 30 d√≠as`,
                        data: prices,
                        borderColor: '#00ffa3',
                        backgroundColor: 'rgba(0, 255, 163, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#e2e8f0' } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataPoint = sampledData[context.dataIndex];
                                    const price = context.parsed.y;
                                    const type = dataPoint.isSimulated ? ' (simulado)' : dataPoint.isReal ? ' (real)' : '';
                                    return `$${price.toFixed(4)}${type}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { color: 'rgba(71, 85, 105, 0.3)' },
                            ticks: { 
                                color: '#94a3b8',
                                maxTicksLimit: 12
                            }
                        },
                        y: {
                            grid: { color: 'rgba(71, 85, 105, 0.3)' },
                            ticks: { 
                                color: '#94a3b8',
                                callback: function(value) {
                                    return '$' + value.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });
            
            updateIndicators(generateInitialIndicators());
            updateAnalysisText('inicializaci√≥n');
        }
        
        function sampleData(data, maxPoints) {
            if (data.length <= maxPoints) return data;
            
            const sampled = [];
            const step = data.length / maxPoints;
            
            for (let i = 0; i < maxPoints; i++) {
                const index = Math.floor(i * step);
                sampled.push(data[index]);
            }
            
            return sampled;
        }
        
        function updateChartForPeriod(query) {
            const periodInfo = parsePeriodQuery(query);
            
            // Determinar si debemos incluir datos simulados
            let includeSimulated = false;
            
            // Para a√±os completos (especialmente 2025), incluir datos simulados
            if (periodInfo.type === 'year' && periodInfo.year === 2025) {
                includeSimulated = true;
            }
            
            // Para "este a√±o" que es 2025
            if ((query.includes('este a√±o') || query.includes('anual')) && 
                periodInfo.startDate.getFullYear() === 2025) {
                includeSimulated = true;
            }
            
            let periodData;
            
            // Obtener datos seg√∫n el tipo de per√≠odo
            if (periodInfo.type === 'year' && includeSimulated) {
                // Para 2025, usar la funci√≥n especial que genera datos simulados
                periodData = generateYearData(periodInfo.year);
            } else {
                // Para otros per√≠odos, obtener datos normales
                periodData = getDataForPeriod(
                    periodInfo.startDate, 
                    periodInfo.endDate, 
                    false
                );
            }
            
            if (periodData.length === 0) {
                // Si no hay datos, mostrar mensaje
                priceChart.data.labels = ['Sin datos'];
                priceChart.data.datasets = [{
                    label: 'Sin datos disponibles',
                    data: [0],
                    borderColor: '#94a3b8',
                    backgroundColor: 'rgba(148, 163, 184, 0.1)'
                }];
                priceChart.update();
                return;
            }
            
            // Para per√≠odos largos (> 100 puntos), muestrear
            const maxPoints = 100;
            const displayData = periodData.length > maxPoints ? 
                sampleData(periodData, maxPoints) : periodData;
            
            const labels = displayData.map(d => {
                if (periodInfo.type === 'year') {
                    // Para a√±os, mostrar mes y d√≠a
                    return d.date.toLocaleDateString('es-ES', { month: 'short', day: 'numeric' });
                } else if (periodInfo.type === 'last_days' && periodInfo.days <= 30) {
                    // Para per√≠odos cortos, mostrar d√≠a completo
                    return d.date.toLocaleDateString('es-ES', { month: 'short', day: 'numeric' });
                } else {
                    // Para otros, formato m√°s simple
                    const month = d.date.toLocaleDateString('es-ES', { month: 'short' });
                    const day = d.date.getDate();
                    return `${day} ${month}`;
                }
            });
            
            // Separar datos reales y simulados para colores diferentes
            const realPrices = displayData.map(d => d.isReal ? d.close : null);
            const simulatedPrices = displayData.map(d => d.isSimulated ? d.close : null);
            
            // Determinar t√≠tulo
            let chartTitle = '';
            if (periodInfo.type === 'year') {
                chartTitle = `Precio de SOL (USD) - ${periodInfo.year}`;
                if (includeSimulated) {
                    chartTitle += ' (datos reales + simulados)';
                }
            } else if (periodInfo.type === 'last_days') {
                chartTitle = `Precio de SOL (USD) - √öltimos ${periodInfo.days} d√≠as`;
            } else if (periodInfo.type === 'month') {
                chartTitle = `Precio de SOL (USD) - ${periodInfo.month}`;
            } else {
                chartTitle = `Precio de SOL (USD)`;
            }
            
            // Actualizar gr√°fico
            priceChart.data.labels = labels;
            
            // Crear datasets seg√∫n el tipo de datos
            const datasets = [];
            
            // Si hay datos reales, a√±adir dataset
            if (realPrices.some(p => p !== null)) {
                datasets.push({
                    label: 'Datos reales',
                    data: realPrices,
                    borderColor: '#00ffa3',
                    backgroundColor: 'rgba(0, 255, 163, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4
                });
            }
            
            // Si hay datos simulados, a√±adir dataset
            if (simulatedPrices.some(p => p !== null)) {
                datasets.push({
                    label: 'Datos simulados',
                    data: simulatedPrices,
                    borderColor: '#03e1ff',
                    backgroundColor: 'rgba(3, 225, 255, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4,
                    borderDash: [5, 3]
                });
            }
            
            // Si no hay datos de ning√∫n tipo (no deber√≠a pasar), usar datos mixtos
            if (datasets.length === 0) {
                const allPrices = displayData.map(d => d.close);
                datasets.push({
                    label: chartTitle,
                    data: allPrices,
                    borderColor: '#00ffa3',
                    backgroundColor: 'rgba(0, 255, 163, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4
                });
            }
            
            priceChart.data.datasets = datasets;
            
            // Configurar eje X para mostrar menos ticks en per√≠odos largos
            const maxXTicks = periodData.length > 60 ? 8 : 12;
            priceChart.options.scales.x.ticks.maxTicksLimit = maxXTicks;
            
            priceChart.update();
        }
        
        // ============================================
        // FUNCIONES AUXILIARES
        // ============================================
        
        function parsePeriodQuery(query) {
            query = query.toLowerCase();
            
            // Detectar a√±o espec√≠fico
            const yearMatch = query.match(/(\d{4})/);
            if (yearMatch) {
                const year = parseInt(yearMatch[1]);
                return {
                    type: 'year',
                    year: year,
                    startDate: new Date(year, 0, 1),
                    endDate: new Date(year, 11, 31)
                };
            }
            
            // Detectar "anual" o "este a√±o"
            if (query.includes('anual') || query.includes('este a√±o')) {
                const currentYear = 2025; // Siempre 2025 en nuestra simulaci√≥n
                return {
                    type: 'year',
                    year: currentYear,
                    startDate: new Date(currentYear, 0, 1),
                    endDate: new Date(currentYear, 11, 31)
                };
            }
            
            // Detectar "√∫ltimos X d√≠as"
            const daysMatch = query.match(/√∫ltimos\s*(\d+)\s*d[i√≠]as/) || 
                             query.match(/(\d+)\s*d[i√≠]as/);
            if (daysMatch) {
                const days = parseInt(daysMatch[1]);
                const endDate = new Date(currentSimulatedDate);
                const startDate = new Date(currentSimulatedDate);
                startDate.setDate(startDate.getDate() - days);
                
                return {
                    type: 'last_days',
                    days: days,
                    startDate: startDate,
                    endDate: endDate
                };
            }
            
            // Por defecto: √∫ltimos 30 d√≠as
            const defaultStartDate = new Date(currentSimulatedDate);
            defaultStartDate.setDate(defaultStartDate.getDate() - 30);
            
            return {
                type: 'default',
                startDate: defaultStartDate,
                endDate: currentSimulatedDate
            };
        }
        
        function getDataForPeriod(startDate, endDate, includePredictions = false) {
            // Filtrar datos reales dentro del per√≠odo
            let periodData = processedData.filter(d => 
                d.date >= startDate && d.date <= endDate && d.isReal
            );
            
            return periodData;
        }
        
        function getCurrentTime() {
            const now = new Date();
            return now.getHours().toString().padStart(2, '0') + ':' + 
                   now.getMinutes().toString().padStart(2, '0');
        }
        
        function insertExample(text) {
            document.getElementById('userInput').value = text;
        }
        
        function addMessageToChat(sender, message) {
            const chatHistory = document.getElementById('chatHistory');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            
            const time = getCurrentTime();
            messageDiv.innerHTML = `
                <div class="message-bubble">${message}</div>
                <div class="message-time">${time}</div>
            `;
            
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }
        
        function simulateTyping() {
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message bot-message';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = `
                <div class="message-bubble pulse">Generando gr√°fico...</div>
                <div class="message-time">${getCurrentTime()}</div
            `;
            
            document.getElementById('chatHistory').appendChild(typingDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
            
            return typingDiv;
        }
        
        function removeTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        function updateIndicators(indicators) {
            const indicatorsContainer = document.getElementById('indicators');
            indicatorsContainer.innerHTML = '';
            
            indicators.forEach(indicator => {
                const indicatorDiv = document.createElement('div');
                indicatorDiv.className = 'indicator';
                
                let statusClass = '';
                if (indicator.status === 'positive') statusClass = 'positive';
                else if (indicator.status === 'warning') statusClass = 'warning';
                else statusClass = 'neutral';
                
                indicatorDiv.innerHTML = `
                    <div style="font-size: 0.9rem; color: #94a3b8;">${indicator.name}</div>
                    <div class="indicator-value ${statusClass}">${indicator.value}</div>
                    <div style="font-size: 0.85rem; color: ${indicator.status === 'positive' ? '#00ffa3' : indicator.status === 'warning' ? '#fbbf24' : '#03e1ff'}">
                        ${indicator.change}
                    </div>
                `;
                
                indicatorsContainer.appendChild(indicatorDiv);
            });
        }
        
        function updateAnalysisText(query) {
            const analysisResults = document.getElementById('analysisResults');
            const analysisCard = analysisResults.querySelector('.analysis-card') || document.createElement('div');
            
            const periodInfo = parsePeriodQuery(query);
            let analysisText = '';
            
            if (periodInfo.type === 'year' && periodInfo.year === 2025) {
                analysisText = `
                    <h3>Gr√°fico Anual 2025</h3>
                    <p>Este gr√°fico muestra datos de Solana para el a√±o 2025. Como tenemos datos reales solo hasta ${lastRealDate.toLocaleDateString('es-ES')}, el resto del a√±o se completa con datos simulados basados en tendencias hist√≥ricas.</p>
                    <p style="margin-top: 10px; color: #94a3b8; font-size: 0.9rem;">Datos reales: Hasta ${lastRealDate.toLocaleDateString('es-ES')} | Datos simulados: ${periodInfo.startDate.toLocaleDateString('es-ES')} - ${periodInfo.endDate.toLocaleDateString('es-ES')}</p>
                `;
            } else if (periodInfo.type === 'last_days') {
                analysisText = `
                    <h3>Gr√°fico de los √∫ltimos ${periodInfo.days} d√≠as</h3>
                    <p>Este gr√°fico muestra datos hist√≥ricos reales de Solana desde ${periodInfo.startDate.toLocaleDateString('es-ES')} hasta ${periodInfo.endDate.toLocaleDateString('es-ES')}.</p>
                    <p style="margin-top: 10px; color: #94a3b8; font-size: 0.9rem;">Per√≠odo: ${periodInfo.days} d√≠as | Datos: ${processedData.length} registros totales</p>
                `;
            } else {
                analysisText = `
                    <h3>An√°lisis del Per√≠odo</h3>
                    <p>El gr√°fico muestra datos de Solana para el per√≠odo solicitado.</p>
                    <p style="margin-top: 10px; color: #94a3b8; font-size: 0.9rem;">Per√≠odo: ${periodInfo.startDate.toLocaleDateString('es-ES')} - ${periodInfo.endDate.toLocaleDateString('es-ES')}</p>
                `;
            }
            
            if (!analysisResults.querySelector('.analysis-card')) {
                analysisCard.className = 'analysis-card';
                analysisResults.insertBefore(analysisCard, indicatorsContainer);
            }
            
            analysisCard.innerHTML = analysisText;
        }
        
        // ============================================
        // AN√ÅLISIS DE CONSULTAS
        // ============================================
        
        function analyzeQuery(query) {
            query = query.toLowerCase();
            let response = '';
            let indicators = [];
            
            if (query.includes('gr√°fico') || query.includes('grafico') || 
                query.includes('muestra') || query.includes('ver')) {
                
                lastQueryType = 'chart';
                const periodInfo = parsePeriodQuery(query);
                
                let periodDesc = '';
                if (periodInfo.type === 'year') {
                    periodDesc = `del a√±o ${periodInfo.year}`;
                    if (periodInfo.year === 2025) {
                        periodDesc += ' (con datos simulados para completar el a√±o)';
                    }
                } else if (periodInfo.type === 'last_days') {
                    periodDesc = `de los √∫ltimos ${periodInfo.days} d√≠as`;
                } else {
                    periodDesc = `del per√≠odo solicitado`;
                }
                
                response = `He generado un gr√°fico ${periodDesc}.`;
                indicators = generateInitialIndicators();
                updateChartForPeriod(query);
                
            } else if (query.includes('precio') && query.includes('ma√±ana')) {
                
                lastQueryType = 'prediction';
                const predictedPrice = generatePrediction(1);
                const changePercent = ((predictedPrice - currentSimulatedPrice) / currentSimulatedPrice * 100).toFixed(2);
                
                response = `
                    Mi predicci√≥n para ma√±ana es: <strong>$${predictedPrice.toFixed(2)}</strong><br>
                    Cambio estimado: <strong>${changePercent}%</strong> ${parseFloat(changePercent) > 0 ? 'üìà' : 'üìâ'}<br><br>
                    Esta predicci√≥n se basa en el an√°lisis de volatilidad hist√≥rica.
                `;
                
                indicators = generatePredictionIndicators();
                
            } else {
                lastQueryType = 'general';
                response = `
                    Puedo mostrarte:<br>
                    ‚Ä¢ <strong>Gr√°fico de 2025</strong> (a√±o completo con datos simulados)<br>
                    ‚Ä¢ <strong>Gr√°fico anual</strong> (a√±o actual 2025)<br>
                    ‚Ä¢ <strong>Gr√°fico de los √∫ltimos X d√≠as</strong> (ej: 7, 30, 90 d√≠as)<br>
                    ‚Ä¢ <strong>Predicciones</strong> para ma√±ana o pr√≥ximos d√≠as
                `;
                indicators = generateInitialIndicators();
            }
            
            return { response, indicators };
        }
        
        // ============================================
        // GENERADORES DE INDICADORES
        // ============================================
        
        function generateInitialIndicators() {
            return [
                { name: 'Precio Actual', value: `$${currentSimulatedPrice.toFixed(2)}`, change: '+1.2%', status: 'positive' },
                { name: 'Volumen 24h', value: '$2.4B', change: '+5.7%', status: 'positive' },
                { name: 'Volatilidad', value: '28.5%', change: 'Alta', status: 'warning' },
                { name: 'RSI (14 d√≠as)', value: '62.5', change: 'Neutral', status: 'neutral' },
                { name: 'SMA (50 d√≠as)', value: `$${(currentSimulatedPrice * 0.98).toFixed(2)}`, change: 'Soporte', status: 'neutral' },
                { name: 'Sentimiento', value: 'Positivo', change: '72%', status: 'positive' }
            ];
        }
        
        function generatePredictionIndicators() {
            const tomorrowPrice = generatePrediction(1);
            const changePercent = ((tomorrowPrice - currentSimulatedPrice) / currentSimulatedPrice * 100).toFixed(2);
            
            return [
                { name: 'Precio Actual', value: `$${currentSimulatedPrice.toFixed(2)}`, change: '+1.2%', status: 'positive' },
                { name: 'Predicci√≥n 24h', value: `$${tomorrowPrice.toFixed(2)}`, change: `${changePercent}%`, status: parseFloat(changePercent) > 0 ? 'positive' : 'warning' },
                { name: 'Confianza', value: '78%', change: 'Alta', status: 'positive' },
                { name: 'Rango Esperado', value: `$${(tomorrowPrice * 0.97).toFixed(2)}-$${(tomorrowPrice * 1.03).toFixed(2)}`, change: '¬±3.2%', status: 'warning' },
                { name: 'Volatilidad Est.', value: '2.8%', change: 'Media', status: 'neutral' },
                { name: 'Recomendaci√≥n', value: parseFloat(changePercent) > 1 ? 'Observar' : 'Neutral', change: 'Neutral', status: 'neutral' }
            ];
        }
        
        // ============================================
        // MANEJO DE INTERACCI√ìN
        // ============================================
        
        function processUserInput() {
            const userInput = document.getElementById('userInput').value.trim();
            if (!userInput) return;
            
            addMessageToChat('user', userInput);
            document.getElementById('userInput').value = '';
            
            const typingIndicator = simulateTyping();
            
            setTimeout(() => {
                removeTypingIndicator();
                
                const analysis = analyzeQuery(userInput);
                addMessageToChat('bot', analysis.response);
                
                updateIndicators(analysis.indicators);
                updateAnalysisText(userInput);
            }, 1500);
        }
        
        // ============================================
        // INICIALIZACI√ìN
        // ============================================
        
        async function initializeApp() {
            try {
                await loadCSVData();
                
                initializeChart();
                
                document.getElementById('userInput').placeholder = "Pide un gr√°fico (ej: gr√°fico de 2025, √∫ltimos 30 d√≠as)";
                document.getElementById('userInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
                document.getElementById('queryExamples').style.display = 'flex';
                
                const chatHistory = document.getElementById('chatHistory');
                chatHistory.innerHTML = '';
                
                addMessageToChat('bot', `
                    ¬°Listo! He cargado <strong>${processedData.length} registros</strong> de datos reales de Solana.<br><br>
                    <strong>Ahora puedes:</strong><br>
                    ‚Ä¢ Pedir <strong>"gr√°fico de 2025"</strong> para ver el a√±o completo (con datos simulados)<br>
                    ‚Ä¢ Pedir <strong>"gr√°fico de los √∫ltimos 7 d√≠as"</strong> para datos reales recientes<br>
                    ‚Ä¢ Pedir <strong>"gr√°fico anual"</strong> (igual que 2025)<br>
                    ‚Ä¢ Pedir <strong>"predice el precio para ma√±ana"</strong><br><br>
                    ¬øQu√© te gustar√≠a ver?
                `);
                
                document.getElementById('sendButton').addEventListener('click', processUserInput);
                document.getElementById('userInput').addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') processUserInput();
                });
                
            } catch (error) {
                console.error('Error:', error);
                addMessageToChat('bot', 'Error cargando datos. Usando datos de ejemplo.');
                initializeChart();
                document.getElementById('userInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
            }
        }
        
        window.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>